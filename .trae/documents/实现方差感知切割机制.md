# 实现方差感知切割机制计划

## 1. 实现目标

根据论文描述，实现方差感知切割机制，每10轮感知一次并变化N值，同时清空上一轮全局原型。

## 2. 实现步骤

### 2.1 编写方差感知切割函数

* 函数名：`calculate_optimal_N`

* 功能：计算每个特征维度的方差，确定最优的N值

* 输入：全局域特定原型、类别数、特征总维度、方差阈值

* 输出：最优N值

### 2.2 修改main.py中的N值计算逻辑

* 移除当前的线性增长逻辑

* 每10轮执行一次方差感知切割

* 初始N值设为0

* 30轮后开始执行方差感知切割

### 2.3 重置全局原型

* 当N值变化时，清空所有全局原型和本地原型

* 确保新的N值生效

## 3. 具体实现

### 3.1 方差感知切割函数实现

```python
def calculate_optimal_N(global_cluster_N_M_protos, num_classes, total_dim, var_threshold=0.5):
    # 收集所有域特定原型
    all_protos = []
    for label in global_cluster_N_M_protos:
        for proto in global_cluster_N_M_protos[label]:
            all_protos.append(proto)
    
    if not all_protos:
        return 0
    
    all_protos = np.array(all_protos)
    
    # 计算每个维度的方差
    dim_vars = np.var(all_protos, axis=0)
    
    # 计算类别间的平均方差
    class_vars = {}
    for label in global_cluster_N_M_protos:
        protos = np.array(global_cluster_N_M_protos[label])
        if len(protos) > 1:
            class_vars[label] = np.var(protos, axis=0)
    
    if class_vars:
        avg_class_vars = np.mean(np.array(list(class_vars.values())), axis=0)
    else:
        avg_class_vars = dim_vars
    
    # 计算最优N值：方差小于阈值的维度数
    optimal_N = np.sum(avg_class_vars < var_threshold)
    
    return optimal_N
```

### 3.2 修改main.py中的N值计算

* 在proposed函数中添加方差感知切割逻辑，注意N一定是一个介于1-512的整数，

* 每10轮执行一次

* 30轮后开始执行

### 3.3 重置全局原型

* 当N值变化时，清空所有全局原型和本地原型

## 4. 执行计划

1. 修改main.py文件，添加方差感知切割函数
2. 修改N值计算逻辑
3. 测试代码运行

现在我将开始执行这个计划。
